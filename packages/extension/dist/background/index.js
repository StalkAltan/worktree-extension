var P="http://localhost:21547";var Y="config";var q={serverUrl:"http://localhost:21547",worktreeRoot:"",terminalCommand:"ghostty -e bash -c 'cd {directory} && opencode'",projectMappings:{}};var S=1e4;class z extends Error{status;code;constructor(H,J,X){super(H);this.status=J;this.code=X;this.name="ApiError"}}class I extends Error{constructor(H){super(H);this.name="NetworkError"}}class x extends Error{directory;constructor(H,J){super(H);this.directory=J;this.name="WorktreeExistsError"}}function W(H){let J=new AbortController;return setTimeout(()=>J.abort(),H),J}async function V(H,J={},X=S){let Z=W(X);try{return await fetch(H,{...J,signal:Z.signal})}catch($){if($ instanceof Error){if($.name==="AbortError")throw new I(`Request timed out after ${X}ms`);if($.message.includes("Failed to fetch")||$.message.includes("NetworkError")||$.message.includes("ERR_CONNECTION_REFUSED"))throw new I("Unable to connect to server. Is the worktree server running?")}throw $}}async function B(H){if(!H.headers.get("content-type")?.includes("application/json"))throw new z("Server returned non-JSON response",H.status,"invalid_response");return await H.json()}async function y(H=P){let J=await V(`${H}/health`,{method:"GET",headers:{Accept:"application/json"}});if(!J.ok)throw new z("Health check failed",J.status,"health_check_failed");return B(J)}async function G(H,J=P){let X=await V(`${J}/worktree/create`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify(H)});if(X.status===409){let Z=await B(X);throw new x(Z.message,Z.directory)}if(!X.ok){let Z=await B(X);throw new z(Z.message,X.status,Z.error)}return B(X)}async function O(H,J=P){let X=await V(`${J}/worktree/open`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify(H)});if(!X.ok){let Z=await B(X);throw new z(Z.message,X.status,Z.error)}return B(X)}async function Q(){return(await chrome.storage.sync.get(Y))[Y]??q}async function K(H){await chrome.storage.sync.set({[Y]:H})}async function b(H){let J=await Q();await K({...J,...H})}async function F(H,J){let X=await Q();X.projectMappings[H]=J,await K(X)}async function N(H){let J=await Q();delete J.projectMappings[H],await K(J)}async function w(H){return(await Q()).projectMappings[H]}async function L(H){try{switch(H.type){case"GET_CONFIG":return{success:!0,data:await Q()};case"SAVE_CONFIG":return await K(H.config),{success:!0};case"UPDATE_CONFIG":return await b(H.updates),{success:!0};case"ADD_PROJECT_MAPPING":return await F(H.projectCode,H.mapping),{success:!0};case"REMOVE_PROJECT_MAPPING":return await N(H.projectCode),{success:!0};case"GET_PROJECT_MAPPING":return{success:!0,data:await w(H.projectCode)};case"HEALTH_CHECK":return{success:!0,data:await y(H.serverUrl)};case"CREATE_WORKTREE":return{success:!0,data:await G(H.request,H.serverUrl)};case"OPEN_WORKTREE":return{success:!0,data:await O(H.request,H.serverUrl)};default:return{success:!1,error:`Unknown message type: ${H.type}`}}}catch(J){if(J instanceof x)return{success:!1,error:J.message,errorType:"WorktreeExistsError",directory:J.directory};if(J instanceof z)return{success:!1,error:J.message,errorType:"ApiError"};if(J instanceof I)return{success:!1,error:J.message,errorType:"NetworkError"};return{success:!1,error:J instanceof Error?J.message:"Unknown error occurred"}}}chrome.runtime.onMessage.addListener((H,J,X)=>{return L(H).then(X),!0});console.log("[Worktree Extension] Background service worker initialized");
