var Y="http://localhost:21547";var x="config";var q={serverUrl:"http://localhost:21547",worktreeRoot:"",terminalCommand:"ghostty -e bash -c 'cd {directory} && opencode'",workspaces:{}};var j=1e4;class B extends Error{status;code;constructor(H,J,X){super(H);this.status=J;this.code=X;this.name="ApiError"}}class K extends Error{constructor(H){super(H);this.name="NetworkError"}}class P extends Error{directory;constructor(H,J){super(H);this.directory=J;this.name="WorktreeExistsError"}}function M(H){let J=new AbortController;return setTimeout(()=>J.abort(),H),J}async function V(H,J={},X=j){let Z=M(X);try{return await fetch(H,{...J,signal:Z.signal})}catch(z){if(z instanceof Error){if(z.name==="AbortError")throw new K(`Request timed out after ${X}ms`);if(z.message.includes("Failed to fetch")||z.message.includes("NetworkError")||z.message.includes("ERR_CONNECTION_REFUSED"))throw new K("Unable to connect to server. Is the worktree server running?")}throw z}}async function Q(H){if(!H.headers.get("content-type")?.includes("application/json"))throw new B("Server returned non-JSON response",H.status,"invalid_response");return await H.json()}async function y(H=Y){let J=await V(`${H}/health`,{method:"GET",headers:{Accept:"application/json"}});if(!J.ok)throw new B("Health check failed",J.status,"health_check_failed");return Q(J)}async function G(H,J=Y){let X=await V(`${J}/worktree/create`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify(H)});if(X.status===409){let Z=await Q(X);throw new P(Z.message,Z.directory)}if(!X.ok){let Z=await Q(X);throw new B(Z.message,X.status,Z.error)}return Q(X)}async function O(H,J=Y){let X=await V(`${J}/worktree/open`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify(H)});if(!X.ok){let Z=await Q(X);throw new B(Z.message,X.status,Z.error)}return Q(X)}async function $(){return(await chrome.storage.sync.get(x))[x]??q}async function I(H){await chrome.storage.sync.set({[x]:H})}async function b(H){let J=await $();await I({...J,...H})}async function F(){let H=await $();return H.projectMappings!==void 0&&Object.keys(H.projectMappings).length>0}async function N(H){let J=await $();if(!J.projectMappings||Object.keys(J.projectMappings).length===0)return;if(!J.workspaces)J.workspaces={};if(!J.workspaces[H])J.workspaces[H]={projectMappings:{}};for(let[X,Z]of Object.entries(J.projectMappings))J.workspaces[H].projectMappings[X]=Z;delete J.projectMappings,await I(J)}async function S(H){return(await $()).workspaces?.[H]??{projectMappings:{}}}async function L(H,J,X){let Z=await $();if(!Z.workspaces)Z.workspaces={};if(!Z.workspaces[H])Z.workspaces[H]={projectMappings:{}};Z.workspaces[H].projectMappings[J]=X,await I(Z)}async function D(H,J){let X=await $();if(X.workspaces?.[H]?.projectMappings)delete X.workspaces[H].projectMappings[J],await I(X)}async function _(H,J){return(await $()).workspaces?.[H]?.projectMappings?.[J]}async function W(H){try{switch(H.type){case"GET_CONFIG":return{success:!0,data:await $()};case"SAVE_CONFIG":return await I(H.config),{success:!0};case"UPDATE_CONFIG":return await b(H.updates),{success:!0};case"ADD_PROJECT_MAPPING":return await L(H.workspace,H.projectCode,H.mapping),{success:!0};case"REMOVE_PROJECT_MAPPING":return await D(H.workspace,H.projectCode),{success:!0};case"GET_PROJECT_MAPPING":return{success:!0,data:await _(H.workspace,H.projectCode)};case"NEEDS_MIGRATION":return{success:!0,data:await F()};case"MIGRATE_PROJECT_MAPPINGS":return await N(H.workspace),{success:!0};case"GET_WORKSPACE_CONFIG":return{success:!0,data:await S(H.workspace)};case"HEALTH_CHECK":return{success:!0,data:await y(H.serverUrl)};case"CREATE_WORKTREE":return{success:!0,data:await G(H.request,H.serverUrl)};case"OPEN_WORKTREE":return{success:!0,data:await O(H.request,H.serverUrl)};default:return{success:!1,error:`Unknown message type: ${H.type}`}}}catch(J){if(J instanceof P)return{success:!1,error:J.message,errorType:"WorktreeExistsError",directory:J.directory};if(J instanceof B)return{success:!1,error:J.message,errorType:"ApiError"};if(J instanceof K)return{success:!1,error:J.message,errorType:"NetworkError"};return{success:!1,error:J instanceof Error?J.message:"Unknown error occurred"}}}chrome.runtime.onMessage.addListener((H,J,X)=>{return W(H).then(X),!0});console.log("[Worktree Extension] Background service worker initialized");
